---
tags:
  - linux
  - 编程
  - undone
datetime: 2025-04-18
---

# 异步非阻塞串口数据接收

## 异步?
*异步 (asynchronous)* 编程是一种并发的编程模式, 可以有效节省 CPU 阻塞等待 I/O 事件造成的时间浪费, 借以提高性能.

在这里也简单介绍一下 *并行 (parallel)* 与 *并发 (concurrent)* 的区别. 并发是指多个任务可以被同时运行的现象; 但需要注意的是, 并发在某一时刻可能并不一定有多个任务在运行. 但是并行是严格的多线程工作模式, 在某一时刻有多个任务在同时工作. 于是很容易看出, 并行也被包含在并发之中.

异步的核心在于一个字 "**等**". 简而言之, 异步编程好似去食堂窗口买饭, 当你告诉他你要点的餐以后, 不是一定要在窗口前等着, 而是可以去做点别的事情, 比如买瓶饮料什么的, 直到老板通知你取餐, 这就是一次异步事件. 在编程时我们调用一个异步 API, 若它不能立刻返回结果, 那么也不会阻塞等待, 而是立刻向后执行; 直到获取到结果再通知我们进行处理.

不同的语言有各色的异步支持, `JavaScript` 和 `Rust` 的异步模型都很有代表性. `JavaScript` 中, 异步函数可以返回一个 `Promise` 对象, 其名字形象地说明了它的功能: 我承诺完成你要的操作; 潜台词则是我保证 **将来** 会完成你要的操作, 不一定是立刻做到. `Rust` 的 `Future` 机制则更为直白: 你的任务我将来会完成的.

非多线程的异步程序的本质是 CPU 的 **时分复用**, 它用划分时间片交替运行各项任务来模拟同时运行每项任务. 必须指出, 有些语言实际上使用多线程实现的异步, 在这种情况下可以实现真正的并行, 即每个时刻多项任务同时被运行. 于是很容易推断, 若 CPU 本来就没有空闲时间, 那么非多线程的异步也并不能提高效率. 这也是为什么异步大多都被用于 I/O 操作, 因为可以有效利用好 I/O 事件中因为等待而空闲的 CPU 时间. 若是 CPU 密集型的工作, 例如科学计算等, 使用异步模型反而会因为时间片切换而损失性能. 这种情况更适合用多线程的方法提高效率.

异步模型的通知机制, 也就是当任务完成时如何处理结果, 是各种异步模型要解决的核心问题, 不同的解决方案也催生出不同的异步模型. 最为简单的方法自然是传递一个回调函数, 当任务完成时调用回调来处理结果. 这也被称为 *事件驱动 (Event Driven)* 模型.

## `libuv` 使用
`libuv` 是 `c` 语言编写的强调异步 I/O 的多平台支持库. 我们的目标是使用它编写异步的接收串口数据程序.

我们以异步打开文件来举例:
```c
uv_fs_t open_req;

void on_open(uv_fs_t *req) {
	if (req->result >= 0) {
		// do something...
	}
}

int main() {
	const char* fname = "/...";
	uv_fs_open(uv_default_loop(), &open_req, fname, O_RDONLY, 0, on_open);

	uv_run(uv_default_loop(), UV_RUN_DEFAULT);

	uv_fs_req_cleanup(&open_req);
	return 0;
}
```
